<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ReplState" timestamp="1426564203643">{:repl-history {:ide [], :local [&quot;y&quot; &quot;(def z (t/now))&quot; &quot;z&quot; &quot;(t/before y z)&quot; &quot;(t/before? y z)&quot; &quot;(t/before? z y)&quot; &quot;(t/before? (t/plus y (t/minutes 5)) z)&quot; &quot;(t/minus (t/now) (t/minutes 5))&quot; &quot;(:time (get-in @job-store [:jobs 2]))&quot; &quot;(t/before? (:time (get-in @job-store [:jobs 2]))\n           (t/minus (t/now) (t/minutes 5)))&quot; &quot;t/now&quot; &quot;(t/now)&quot; &quot;(t/before? z\n(t/minus (t/now) (t/minutes 5)))&quot; &quot;(into {} '(1 2 4))&quot; &quot;(for [x (:jobs @job-store)]\n  (inc x))&quot; &quot;(for [x (:jobs @job-store)]\n  (inc (keys x)))&quot; &quot;(for [x (:jobs @job-store)]\n  (keys x))&quot; &quot;(for [x (:jobs @job-store)]\n  {(keys x) (vals x)})&quot; &quot;(for [x {:a 1 :b 2}]\n  x)&quot; &quot;(map identity {:a 1 :b 2})&quot; &quot;(for [x (:jobs @job-store)]\n  x)&quot; &quot;(into {} (for [x (:jobs @job-store)]\n  x))&quot; &quot;(defn zulu [m k v]\n  (if (= v 50)\n    (assoc m k v)\n    m))&quot; &quot;(zulu {:a 1 :b 2} :c 5)&quot; &quot;(zulu {:a 1 :b 2} :c 50)&quot; &quot;(reduce-kv zulu {} {:c 50, :b 2, :a 1})&quot; &quot;(reduce-kv zulu {} {:c 50, :b 50, :a 1})&quot; &quot;(defn delete-old-jobs [jobs]\n  (let end-time (t/minus (t/now) (t/minutes 5))\n       time-filter (partial end-time job-filter)\n      (reduce-kv time-filter {} jobs)))&quot; &quot;(defn job-filter [time m k v]\n  (if (t/before? (:time v) time)\n    (assoc m k v)\n    m))&quot; &quot;(defn delete-old-jobs [jobs]\n  (let [end-time (t/minus (t/now) (t/minutes 5))\n       time-filter (partial end-time job-filter)]\n      (reduce-kv time-filter {} jobs)))&quot; &quot;(:jobs @job-store)&quot; &quot;(defn add-job-to-db [job]\n  (swap! job-store assoc-in [:jobs (:id job)] (assoc job :time (t/now))))&quot; &quot;(add-job-to-db {:id 1 :total 5 :progress 10})&quot; &quot;(add-job-to-db {:id 2 :total 50 :progress 5})&quot; &quot;(add-job-to-db {:id 2 :total 90 :progress 80})&quot; &quot;(add-job-to-db {:id 3 :total 50 :progress 5})&quot; &quot;(job-filter (get-in (:jobs @jobs) [:jobs 2]))&quot; &quot;(job-filter (get-in (:jobs @job-store) [:jobs 2]))&quot; &quot;(get-in (:jobs @job-store) [:jobs 2])&quot; &quot;(get-in  [:jobs 2] (:jobs @job-store))&quot; &quot;(get (:jobs @job-store) )&quot; &quot;(get-in  [:jobs 2] @job-store)&quot; &quot;(get-in [:jobs] @job-store)&quot; &quot;(get-in @job-store [:jobs])&quot; &quot;(get-in @job-store [:jobs 2])&quot; &quot;(job-filter (get-in @job-store [:jobs 2]))&quot; &quot;(job-filter (t/now) {} 2 (get-in @job-store [:jobs 2]))&quot; &quot;(defn delete-old-jobs [jobs]\n  (let [end-time (t/minus (t/now) (t/minutes 5))\n       time-filter (partial job-filter end-time)]\n      (reduce-kv time-filter {} jobs)))&quot; &quot;(delete-old-jobs (:jobs @jobs))&quot; &quot;(defn job-timed-out? [job-time-stamp end-time]\n  (t/before? job-time-stamp end-time))\n\n(defn job-filter [end-time m k v]\n  (if job-timed-out? (:time v) end-time)\n  (assoc m k v)\n  m)\n\n(defn delete-old-jobs [jobs]\n  (let [time-filter (partial job-filter (t/minus (t/now) (t/minutes 5)))]\n    (reduce-kv time-filter {} jobs)))&quot; &quot;(if-let [a true]\n  (+ 1 2)\n  (+ 3 4))&quot; &quot;(if-let [a false]\n  (+ 1 2)\n  (+ 3 4))&quot; &quot;(atom a {})&quot; &quot;(def a (atom {}))&quot; &quot;(swap! a {:a 1 :b 2})&quot; &quot;@a&quot; &quot;(swap! a (assoc :b 3))&quot; &quot;(swap! a assoc :b 3)&quot; &quot;(swap! a assoc :c 2)&quot; &quot;(swap! job-store assoc :jobs (delete-old-jobs (vals (:jobs @job-store))))&quot; &quot;(delete-old-jobs (:jobs @job-store))&quot; &quot;(defn delete-old-jobs [jobs]\n  (let [time-filter (partial job-filter (t/minus (t/now) (t/minutes 5)))\n        job-map (:jobs jobs)]\n    (hash-map :jobs (reduce-kv time-filter {} job-map))))&quot; &quot;(def job1 {:id 1 :total 50 :progress 20})\n(def job2 {:id 2 :total 75 :progress 100})\n(def job3 {:id 3 :total 7 :progress 70})&quot; &quot;{:jobs {1 job1}}&quot; &quot;(hash-map {:jobs {1 job1}})&quot; &quot;(hash-map :jobs (hash-map 1 job1))&quot; &quot;job-map&quot; &quot;(defn add-job-to-db [job]\n  (swap! job-store assoc-in [:jobs (:id job)] (assoc job :time (t/now))))\n\n(defn job-timed-out? [job-time-stamp end-time]\n  (t/before? job-time-stamp end-time))\n\n(defn job-filter [end-time m k v]\n  (if job-timed-out? (:time v) end-time)\n  (assoc m k v)\n  m)\n\n(defn delete-old-jobs [jobs]\n  (let [time-filter (partial job-filter (t/minus (t/now) (t/minutes 5)))\n        job-map (:jobs jobs)]\n    (hash-map :jobs (reduce-kv time-filter {} job-map))))\n&quot; &quot;(get-in @job-store [:jobs 1 :time])&quot; &quot;(job-timed-out (get-in @job-store [:jobs 1 :time]) (t/minus (t/now) (t/minutes 5)))&quot; &quot;(job-timed-out? (get-in @job-store [:jobs 1 :time]) (t/minus (t/now) (t/minutes 5)))&quot; &quot;(job-filter (t/minus (t/now) (t/minutes 10)) {} 1 (get-in @job-store [:jobs 1 :time]))&quot; &quot;(job-timed-out? (get-in @job-store [:jobs 1 :time]) (t/minus (t/now) (t/minutes 10)))&quot; &quot;(defn job-filter [end-time m k v]\n  (if (not (job-timed-out? (:time v) end-time))\n    (assoc m k v)\n    m))&quot; &quot;(job-filter (t/minus (t/now) (t/minutes 15)) {} 1 (get-in @job-store [:jobs 1 :time]))&quot; &quot;(job-timed-out? (get-in @job-store [:jobs 1 :time]) (t/minus (t/now) (t/minutes 15)))&quot; &quot;(add-job-to-db job1)&quot; &quot;(add-job-to-db job2)&quot; &quot;(add-job-to-db job3)&quot; &quot;(delete-old-jobs @job-store)&quot; &quot;(let [jobs (:jobs (swap! job-store delete-old-jobs))]\n  {:total (count jobs)\n   :jobs (or (map #(dissoc % :time) jobs) [])})&quot; &quot;(let [jobs (:jobs (swap! job-store delete-old-jobs))])\n &quot; &quot;(swap! job-store delete-old-jobs)&quot; &quot;(:jobs (swap! job-store delete-old-jobs))&quot; &quot;(map #(dissoc % :time) (:jobs (swap! job-store delete-old-jobs)))&quot; &quot;(map #(dissoc % :time) (vals (:jobs (swap! job-store delete-old-jobs))))&quot; &quot;(let [jobs (:jobs (swap! job-store delete-old-jobs))]\n  {:total (count jobs)\n   :jobs (or (map #(dissoc % :time) (vals jobs)) [])})&quot; &quot;(reset! job-store {})&quot; &quot;(let [jobs (:jobs (swap! job-store delete-old-jobs))]\n  {:total (count jobs)\n   :jobs (or (vec (map #(dissoc % :time) (vals jobs))) [])})&quot; &quot;(doseq (printls \&quot;abc\&quot;) (println \&quot;def\&quot;))&quot; &quot;(do (printls \&quot;abc\&quot;) (println \&quot;def\&quot;))&quot; &quot;(do (println \&quot;abc\&quot;) (println \&quot;def\&quot;))&quot; &quot;(server/start)&quot; &quot;(@job-store)&quot; &quot;(get-in (swap! job-store identity) [:job 1])&quot; &quot;()&quot; &quot;(in-ns 'api-test.server)&quot; &quot;(in-ns 'api-test.service)&quot; &quot;@job-store&quot; &quot;(get-in (swap! job-store identity) [:jobs 1])&quot; &quot;(run-dev)&quot;], :remote []}}</component>
</project>